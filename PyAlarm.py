#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        PyAlarm.py
#
# description : Python source for the PyAlarm and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyAlarm are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  sergi_rubio at cells$
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :   ALBA Synchrotron Light Facility
#                Barcelona
#                Europe
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================

import sys
import os
import time
import threading
import traceback
import re
import collections

import PyTango
import fandango
import fandango.functional as fun
from fandango.device import TangoEval
from fandango.log import except2str
from fandango.objects import __lock__, self_locked,Singleton
from fandango.dicts import defaultdict_fromkey
try:
    from fandango.threads import WorkerProcess,getPickable
    PROCESS = True
except: 
    PROCESS = False

# It should work only in PyTango7
# if 'PyUtil' not in dir(PyTango):
    #PyTango.PyDeviceClass = PyTango.DeviceClass
    #PyTango.PyUtil = PyTango.Util

MAJOR_VERSION = '4'
MINOR_VERSION = '8'
__RELEASE__ = "%s.%s: srubio-12.3.30"%(MAJOR_VERSION,MINOR_VERSION)

###############################################################################
# Checking Dependencies

try:
    import panic 
except:
    print 'Unable to load panic module: %s'%traceback.format_exc()

try:
    import smslib
    SMS_ALLOWED=True
except Exception,e: 
    print 'UNABLE TO LOAD SMSLIB ... SMS MESSAGING DISABLED: ',str(e)
    SMS_ALLOWED=False

try:
    from PyTangoArchiving import snap
    SNAP_ALLOWED=True
except Exception,e:
    print 'UNABLE TO LOAD SNAP ... SNAP ARCHIVING DISABLED: ',str(e)
    SNAP_ALLOWED=False
#The device is not ready yet for Snapshoting
#SNAP_ALLOWED=False

try:
    import tau
    USE_TAU=True
except:
    USE_TAU=False
    
USE_STATIC_METHODS = getattr(PyTango,'__version_number__',0)<722

###############################################################################

class SingletonTangoEval(TangoEval,Singleton):
    #All processes must use the same TangoEval object
    pass

class AlarmHook(fandango.Object):
    """
    This class identifies an Action to be executed as response to an alarm.
    :param condition:   a boolean function that will return True if this action is appliable to the given argument.
                        e.g. (condition=lambda s: '@' in s) will apply for mail addresses
    :param action:      function([tag,receivers,...]) to be executed when the action is applied.
    """
    def __init__(self,condition=None,action=None):
        self._condition = condition
        self._action = action
        pass
    def match(self,argument):
        """This method will apply the given condition to the argument. Overridable in subclasses"""
        return self._condition(argument)
    def apply(self,tag,receivers):
        """This method will apply the given action to the argument. Overridable in subclasses"""
        return self._action(tag,receivers)


#==================================================================
#   PyAlarm Class Description:
#
#         This device server is used as a alarm logger, it connects to the list of attributes provided and verifies its values.<br />
#         Its focused on notifying Alarms by log files, Mail, SMS and (some day in the future) electronic logbook.<br />
#         It allows to setup alarms based on attribute values, connection status and boolean combinations of them.<br />
#         Independent configuration and mailing lists available for each alarm.<br/>
#         You can acknowledge these alarms by a proper command.<br />
#         <p>This device requires <a href="http://www.tango-controls.org/Documents/tools/fandango/fandango">Fandango module<a> to be available in the PYTHONPATH.</p>
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :     ActiveAlarms list is empty
#   DevState.ALARM :  Size of ActiveAlarms is >=1
#==================================================================


class PyAlarm(PyTango.Device_4Impl, fandango.log.Logger):

    #--------- Add your global variables here --------------------------

    Panic = None

    MAX_SMS_DAY = 20

    MESSAGE_TYPES = ['ALARM','ACKNOWLEDGED','RECOVERED','REMINDER','AUTORESET','RESET','DISABLED']
    
    #--------------------------------------------------------------------------
    ##Overriding Quality-based Tango state machine
    def set_state(self,state):
        self._state = state
        PyTango.Device_4Impl.set_state(self,state)
        
    def get_state(self):
        #@Tango6
        #This have been overriden as it seemed not well managed when connecting devices in a same server
        return self._state
    
    def dev_state(self):
        #@Tango7
        #This have been overriden to avoid device servers with states managed by qualities
        return self._state
    
    def State(self):
        """ State redefinition is required to keep independency between 
        attribute configuration (max/min alarms) and the device State """
        #return self.get_state()
        return self._state    
    #--------------------------------------------------------------------------

    def alarm_attr_read(self,attr,fire_event=True):
        """
        This is the method where you control the value assignt to each Alarm attributes
        """
        tag_name = attr.get_name()
        value = any(re.match(tag_name.replace('_','.')+'$',a) for a in self.get_active_alarms())
        self.debug('PyAlarm(%s).read_alarm_attribute(%s) is %s; Active Alarms: %s' % (self.get_name(),tag_name,value,self.get_active_alarms()))
        
        self.quality=PyTango.AttrQuality.ATTR_WARNING
        if(self.Alarms[tag_name].severity=='DEBUG'):
            self.quality=PyTango.AttrQuality.ATTR_VALID
        elif(self.Alarms[tag_name].severity=='WARNING'):
            self.quality=PyTango.AttrQuality.ATTR_WARNING
        elif(self.Alarms[tag_name].severity=='ALARM' or self.Alarms[tag_name].severity=='ERROR'):
            self.quality=PyTango.AttrQuality.ATTR_ALARM
        else: self.quality=PyTango.AttrQuality.ATTR_WARNING
        
        attr.set_value_date_quality(value,time.time(),self.quality)
    
    if USE_STATIC_METHODS: alarm_attr_read = staticmethod(self_locked(alarm_attr_read))

    def alarm_attr_allowed(self,req_type):
        """
        Alarms should be always readable, the quality of the alarm will change if needed
        """
        return True
    if USE_STATIC_METHODS: alarm_attr_allowed = staticmethod(alarm_attr_allowed)

    def create_alarm_attribute(self,argin):
        new_attr_name = self.Alarms[argin].get_attribute()
        if new_attr_name in self.DynamicAttributes:
            self.info('PyAlarm(%s): attribute %s already exists' % (self.get_name(),new_attr_name))
        else:
            self.info('PyAlarm(%s): Creating attribute %s for %s alarm' % (self.get_name(),new_attr_name,argin))
            self.add_attribute(PyTango.Attr(new_attr_name,PyTango.ArgType.DevBoolean,PyTango.AttrWriteType.READ),
                self.alarm_attr_read,
                None, #self.write_new_attribute #(attr)
                self.alarm_attr_allowed
                )
            self.DynamicAttributes.append(new_attr_name)
        return new_attr_name

    def dyn_attr(self):
        ## Dynamic Attributes Creator
        self.debug( '#'*40)
        self.info( 'In PyAlarm(%s).dyn_attr()'%self.get_name())
        alarms = self.Alarms.keys()# if hasattr(self,'Alarms') else [a.tag for a in self.panic.get(device=self.get_name())]
        for alarm in alarms:
            try:
                self.create_alarm_attribute(alarm)
                if self.worker: self.worker.add(alarm,'eval',{'formula':self.Alarms[alarm].formula,'_raise':True},period=self.PollingPeriod,expire=self.AlarmThreshold*self.PollingPeriod)
            except:
                self.warning( 'Unable to create %s attribute'%alarm)
                self.warning( traceback.format_exc())
        self._initialized = True
        return

    ###########################################################################

    def parse_receivers(self,tag_name='',filtre=False,receivers=None):
        '''
        Filters the Alarm receivers matching tag_name; also replaces addresses entered in the PhoneBook 
        This method is called from free_alarm and send_alarm.
        '''
        if tag_name not in self.Alarms: return []
        if receivers is None:
            receivers = self.Alarms[tag_name].receivers
            #This check has been already done in AlarmAPI.parse_phonebook(receivers); it can be checked and removed
            for name,value in self.AddressList.items():
                if name in receivers and value:
                    self.info( 'In parse_receivers: %s phone book replaced by %s' % (name,value.split('#')[0]))
                    receivers = receivers.replace(name,value.split('#')[0].strip())
        else: receivers = ','.join(receivers)
        receivers = [r for r in receivers.split(',') if not filtre or filtre in r]
        self.info( 'In parse_receivers(%s): receivers added: %s' % (tag_name,receivers))
        return receivers
        
    def parse_action_receivers(self,tag_name,message,receivers):
        '''
        Filters the alarm receivers extracting ACTION(...) formulas.
        Extracts arguments from every action and return them as a list.
        '''
        actions = []
        re_arglist = '(?:'+'(?:[^()]*)'+'|'+'(?:[^()]*\([^()]*\)[^()]*)'+')'
        if fun.isSequence(receivers): receivers = ','.join(receivers)
        action_receivers = re.findall('ACTION\('+re_arglist+'\)',receivers)
        for ac in action_receivers:
            t = {'DISABLED':'disable','ACKNOWLEDGED':'acknowledge'}.get(message,message.lower())
            #rm = re.search(t.lower()+':((?:.*?)|(?:.*[\(].*[\)].*))'+'[\;\)]',ac)
            #rm = re.search(t.lower()+':('+re_arglist+')[\;\)]',ac)
            rm = re.search('(?:'+t.lower()+'|[*]):'+'('+re_arglist+')[\;\)]',ac)
            if rm: actions.append(rm.group(1))
        self.info('parse_action_receivers(%s,%s): %s'%(tag_name,message,receivers))
        return actions

    ##@name Thread management methods
    # @{

    def start(self):
        if self.updateThread:
            if self.updateThread.isAlive():
                self.warning( 'Start not allowed, thread still working')
                return
            else: del self.updateThread
        self.info( 'Thread Starting')
        self.event.clear()
        self.updateThread = threading.Thread(None,self.updateAlarms,'PyAlarm')
        self.updateThread.setDaemon(True)
        self.updateThread.start()

    def stop(self):
        self.info( 'In PyAlarm.stop() ...')
        self.event.set()
        self.updateThread.join(self.PollingPeriod)
        if self.updateThread.isAlive():
            self.warning( 'Thread '+self.updateThread.getName()+' doesn''t Stop!')
        else:
            self.warning( 'Thread '+self.updateThread.getName()+' Stop')
        if self.worker and self.worker.isAlive(): self.worker.stop()
        return
    ##@}

    ###########################################################################
    def get_alarm_variables(self,alarm='',variables=None):
        if variables is None: variables = self.Eval.parse_variables(self.Alarms[alarm].formula)
        formula = self.Alarms[alarm].formula if alarm in self.Alarms else ''
        if self.worker:
            # Getting the values of variables
            previous = self.worker.get('previous')
            try: 
                #self.debug('previous values: %s'%previous.keys())
                VALUE = dict((k,v) for k,v in previous.items() if any(fun.searchCl(self.Eval.parse_tag(v[0]+'/'+v[1],'.'),k) for v in variables))
                VALUE.update((a,bool(v.active)) for a,v in self.Alarms.items() if a in formula)
            except Exception,e: 
                self.warning('Exception parsing values: %s'%traceback.format_exc()) #except2str(e))
                VALUE = {'Exception':str(previous)}
            return VALUE
        else:
            #get_target = lambda v: v[0] + (v[1] and '/%s'%v[1]) + (v[2] and '.%s'%v[2])
            #self.Eval.last.update(dict((get_target(v),'...') for v in variables if v not in self.Eval.last))
            return self.Eval.last
    
    
    def updateAlarms(self):
        self.info( 'In PyAlarm::updateAlarms ...')
        self.event.clear()
        polled_attrs = []
        if time.time()<(self.TStarted+self.StartupDelay):
            self.info('Alarms evaluation not started yet, waiting StartupDelay=%d seconds.'%self.StartupDelay)
            self.event.wait(self.StartupDelay-(time.time()-self.TStarted))
        if self.worker:
            if not self.worker.isAlive(): self.worker.start()
            self.event.wait(self.PollingPeriod)
        while not self.event.isSet():
            try:
                try:
                    #self.Alarms.servers.db.get_info()
                    fandango.tango.get_database_device().state()
                except:
                    self.warning('Tango database is not available!\n%s'%traceback.format_exc())
                    self.set_state(PyTango.DevState.FAULT)
                    for k in self.Alarms.servers:
                        self.event.wait(self.PollingPeriod/len(self.Alarms.servers))
                        if self.worker: 
                            try: self.worker.send('update_locals',target='update_locals',args={'dct':_locals.items()},callback=None)
                            except: self.error('worker.send(update_locals) failed!: %s'%traceback.format_exc())
                    continue
                ###############################################################
                try:
                    self.lock.acquire()
                    timewait = float(self.PollingPeriod)/(len(self.Alarms) or 1.)
                    self.info( 'updateAlarms(): timewait between polling is %f s'%timewait)
                    if not self.Enabled: self.info( '=============> ALARM SENDING DISABLED!!')
                    myAlarms = sorted(a for a in self.Alarms.items() if a[0] not in self.DisabledAlarms) #copied without disabled alarms
                finally: 
                    self.lock.release()
                ###############################################################
                if not self.worker:
                    try: #When using Taurus it will minimize the CPU usage
                        import taurus
                        tpolling = max((3000,1000*self.PollingPeriod/2))
                        for a in taurus.Factory().tango_attrs.keys():
                            if a not in polled_attrs:
                                polled_attrs.append(a)
                                taurus.Attribute(a).changePollingPeriod(tpolling)
                        self.info('\ttaurus polling period = %d ms'%tpolling)
                    except Exception,e: 
                        self.debug('\tunable to set taurus polling period: %s'%e)
                        #self.warning(traceback.format_exc())
                ###############################################################
                self.info('-'*80+'\n'+'-'*80)
                self.info( 'Enabled alarms to process in next %d s cycle (UseProcess=%s): %s ' % (self.PollingPeriod,self.UseProcess,[a[0] for a in myAlarms]))
                    
                for tag_name, alarm in myAlarms: #Format is:    TAG3:LT/VC/Dev1/Pressure > 1e-4
                    now = self.last_attribute_check = time.time()
                    STATE,variables = False,[]
                    ######################################################################################################################
                    self.debug( '-'*80+'\n'+'%s: Reading alarm tag %s; formula: %s'%(now,tag_name,alarm.formula))
                    try:
                        self.lock.acquire()
                        # Update Locals (Done here to minimize time in which WorkerProcess is IDLE)
                        _locals = dict((tag,alarm.active if tag not in self.DisabledAlarms else False) for tag,alarm in self.Alarms.items())
                        if self.worker:
                            self.worker.send('update_locals',target='update_locals',args={'dct':_locals.items()},callback=None)
                        else: self.Eval.update_locals(_locals)
                        
                        # ALARM EVALUATION
                        #####################################################
                        alarm.formula = self.Panic.replace_alarms(alarm.formula) #This replace those alarm names that are not in locals()
                        variables = self.Eval.parse_variables(alarm.formula,_locals)
                        self.debug('In updateAlarms(%s): variables = %s'%(tag_name,variables))
                        STATE = any((not attribute or attribute.lower().strip() == 'state') for device,attribute,what in variables)
                        self.debug('In updateAlarms(%s): STATE = %s'%(tag_name,STATE))
                        if self.worker:
                            self.debug('\tself.worker.get(%s)'%alarm.tag)
                            VALUE = self.worker.get(alarm.tag,None,_raise=True)
                        else:
                            VALUE = self.Eval.eval(alarm.formula,_raise=True)
                        variables = self.get_alarm_variables(alarm=tag_name,variables=variables)
                        self.debug('%s: %s, Values = %s'%(tag_name,VALUE,variables))
                    except Exception,e:
                        desc = except2str(e)
                        if STATE or self.RethrowAttribute: 
                            self.warning('-> Exception while checking State alarm %s:'%tag_name + '\n%s'%alarm.formula + '\n%s'%(traceback.format_exc()))
                        else:
                            self.debug( '-> Exception while checking alarm %s:\n%s'%(tag_name,desc))
                        if (self.RethrowState and STATE) or (self.RethrowAttribute and not STATE):
                            # STATE EXCEPTION: Exceptions in reading of State attributes will trigger alarms
                            ###################################################################################
                            VALUE = desc or str(e) or 'Exception!' #Must Have a Value!
                            #variables = self.get_alarm_variables(alarm=tag_name,variables=variables)
                            variables = {tag_name:VALUE}
                        else:
                            self.FailedAlarms[tag_name]=desc
                            self.info('-> Exceptions in Non-State attributes (%s) do not trigger Alarm'%(tag_name))
                            self.event.wait(timewait)
                            continue
                    finally: self.lock.release()

                    if VALUE:
                        # The alarm condition is ACTIVE
                        ###################################################
                        WAS_OK = alarm.counter<self.AlarmThreshold
                        # counter and active will not have same values if the alarm is not acknowledged for a while
                        if WAS_OK:
                            #Alarm counters are not increased above Threshold
                            alarm.counter+=1
                        self.info('Alarm %s triggered for %d<%d cycles'%(tag_name,alarm.counter,self.AlarmThreshold))

                        if alarm.counter>=self.AlarmThreshold:
                            # Sending ALARM
                            ########################################################
                            if not alarm.active:
                                #Alarm is sent only if it was not active or it was recovered and just came back to alarm or has passed the reminder cycle
                                self.set_alarm(tag_name)
                                self.LastAlarms.append(time.ctime(now)+': '+tag_name)
                                self.PastValues[tag_name] = variables.copy() if hasattr(variables,'copy') else None #Storing the values that will be sent in the report
                                if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='ALARM',values=variables or None) # <=== HERE IS WHERE THE ALARM IS SENT!

                            # Sending REMINDER
                            ########################################################
                            elif not alarm.acknowledged and self.Reminder and ((alarm.recovered and WAS_OK and self.AlertOnRecovery) or alarm.last_sent<(now-self.Reminder)):
                                    self.info('==========> ALARM %s reminder is sent after %s seconds being active.'%(alarm.tag,self.Reminder))
                                    if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='REMINDER',values=variables or None)
                            alarm.recovered = 0
                    else:
                        # The alarm is NOT active
                        ###################################################
                        if alarm.counter: 
                            alarm.counter-=1
                        if not alarm.counter and alarm.active: #The alarm condition was active in the previous cycle
                            self.PastValues[tag_name] = variables.copy() if hasattr(variables,'copy') else None #Storing the values that will be sent in the report
                            # Alarm RECOVERED
                            #####################################################
                            if not alarm.recovered:
                                self.info('The alarm is still active ... but values came back to reality!')
                                alarm.recovered = now
                                if self.AlertOnRecovery and alarm.tag not in self.AcknowledgedAlarms: 
                                    self.send_alarm(tag_name,message='RECOVERED',values=variables)
                            # Alarm AUTO-RESET
                            #####################################################
                            elif self.AutoReset and alarm.recovered<(now-self.AutoReset):
                                    self.info('==========> ALARM %s has been reset automatically after %s seconds being inactive.'%(alarm.tag,self.AutoReset))
                                    self.free_alarm(alarm.tag,notify=False)
                                    if alarm.tag not in self.AcknowledgedAlarms: self.send_alarm(tag_name,message='AUTORESET',values=variables)

                    self.debug( 'Alarm %s counter is : %s' %(tag_name, alarm.counter))
                    if tag_name in self.FailedAlarms: self.FailedAlarms.pop(tag_name)
                    self.lock.acquire()
                    self.Alarms[tag_name]=alarm
                    self.lock.release()
                    ######################################################################################################################
                    self.event.wait(timewait)
                self.update_flag_file()
                self.update_log_file()
                if not myAlarms: self.event.wait(timewait)
                self.Uncatched=''

            except Exception,e:
                tr=traceback.format_exc()
                self.error( 'Uncatched exception in PyAlarm::updateAlarmsThread:\n%s'%tr + '\n' + '='*80)
                self.Uncatched+=tr+'\n'
                self.event.wait(timewait)
        self.info( 'In updateAlarms(): Thread finished')
        return

    #@self_locked
    def set_alarm(self,tag_name):
        self.debug( '#'*80)
        self.info( 'In set_alarm(%s)'%tag_name)
        try:
            self.lock.acquire()
            if not self.Alarms[tag_name].active:
                self.Alarms[tag_name].active = time.time()
                self.Alarms[tag_name].recovered = 0
                return True
            return False
        finally:
            self.lock.release()

    def get_active_alarms(self):
        return [k for k,v in self.Alarms.items() if v.active]

    #@self_locked
    def free_alarm(self,tag_name,comment='',message=None, notify=True):
        """ message for freeing alarm must be RESET/ACKNOWLEDGED/DISABLED """
        try:
            self.info('-'*80)
            self.info('In free_alarm(%s,%s,%s,%s)'%(tag_name,comment,message,notify))
            self.lock.acquire()
            if message=='RESET' and tag_name in self.DisabledAlarms: 
                self.DisabledAlarms.remove('tag_name')
            if not self.Alarms[tag_name].active:
                return False
            else:
                if message!='ACKNOWLEDGED':
                    date = self.Alarms[tag_name].active
                    self.PastAlarms[date].append(tag_name)
                    self.PastValues[tag_name] = None #Storing the values that triggered the alarm
                    self.Alarms[tag_name].clear()
                    if tag_name in self.AcknowledgedAlarms: self.AcknowledgedAlarms.remove(tag_name)
                if self.Enabled and notify:
                    receivers = self.parse_receivers(tag_name)
                    print '\treceivers: %s'%receivers
                    self.SendMail(self.GenerateReport(tag_name,self.parse_receivers(tag_name,'@',receivers),message=message or 'RESET',user_comment=comment))
                    self.update_log_file()
                    
                    try:
                        if SNAP_ALLOWED and (self.UseSnap or self.parse_receivers(tag_name,'SNAP',receivers)): 
                            self.info('>'*80+'\n'+'triggering snapshot for alarm:'+tag_name)
                            self.trigger_snapshot(tag_name, user_comment=comment)
                    except Exception, e:
                        self.warning( 'PyAlarm.trigger_snapshot crashed with exception:\n%s' % traceback.format_exc())
                    
                    try:
                        if self.parse_receivers(tag_name,'HTML',receivers):
                            self.info('>'*80+'\n'+'saving html report for alarm:'+tag_name)
                            self.SaveHtml(self.GenerateReport(tag_name,message=message or 'RESET',user_comment=comment, html=True))
                    except Exception, e:
                        self.warning( 'PyAlarm.saveHtml crashed with exception:\n%s' % traceback.format_exc())
                    
                    action_receivers = self.parse_action_receivers(tag_name,message,receivers)
                    if action_receivers:
                        self.info('checking %s actions ... %s'%(message,action_receivers))
                        [self.triggerAction(self.Alarms[tag_name],ac) for ac in action_receivers]
        except:
            self.warning( 'ResetAlarm(%s) failed!: %s' % (tag_name,traceback.format_exc()))
        finally:
            self.lock.release()
        self.info('-'*80)

    #########################################################################################################
    ##@name Alarm Sending
    #@{

    def send_alarm(self,tag_name,message='',values=None):
        """
        This method parses receivers and:
         - Sends email/SMS for alarms
         - Sends email/sms for RECOVERED/REMINDER if specified in AlertOnRecovery property
         - Triggers snapshots for ALARMS
         - Saves HTML report
         
        ACKNOWLEDGE/RESET messages are not managed here, but in free_alarm
        """
        self.info('-'*80)
        self.info( 'In PyAlarm.send_alarm(%s,%s,%s)'%(tag_name,message,values))
        try:
            if self.Alarms[tag_name].sent >= self.MaxMessagesPerAlarm:
                self.debug('*'*80)
                self.warning('Too many alarms (%d) already sent for %s!!!' % (self.Alarms[tag_name].sent, tag_name))
                self.debug('*'*80)
                return
            if message in ('ALARM','REMINDER') or self.AlertOnRecovery:
                try:
                    self.lock.acquire()
                    receivers = self.parse_receivers(tag_name)
                    mail_receivers = self.parse_receivers(tag_name,'@',receivers)
                    sms_receivers = self.parse_receivers(tag_name,'SMS',receivers)
                    action_receivers = self.parse_action_receivers(tag_name,message,receivers)
                    self.debug('receivers:\n'+'\n'.join(str(r) for r in (receivers,mail_receivers,sms_receivers,action_receivers)))
                finally:
                    self.lock.release()

                if self.Enabled:
                    if self.Alarms[tag_name].severity=='DEBUG':
                        self.info('%s Alarm with severity==DEBUG do not trigger messaging or snapshoting'%tag_name)
                    else:
                        if mail_receivers: 
                            try:
                                self.SendMail(self.GenerateReport(tag_name,mail_receivers,message=message,values=values))
                            except:
                                self.debug('-'*80)
                                self.warning('Exception sending email!: %s' % traceback.format_exc())
                        #Disabling sms message for those messages not related to new alarms
                        if sms_receivers and message in ('ALARM',) or 'sms' in str(self.AlertOnRecovery).lower(): 
                            try:
                                self.SendSMS(tag_name,sms_receivers,message=message,values=values)
                            except:
                                self.debug('-'*80)
                                self.warning('Exception sending sms!: %s' % traceback.format_exc())
                        if self.parse_receivers(tag_name,'HTML',receivers):
                            try:
                                self.info('saving html report for alarm:'+tag_name)
                                self.SaveHtml(self.GenerateReport(tag_name,message=message,values=values, html=True))
                            except Exception, e:
                                self.warning('PyAlarm.saveHtml crashed with exception:\n%s' % traceback.format_exc())
                        if SNAP_ALLOWED and (self.UseSnap or self.parse_receivers(tag_name,'SNAP',receivers)): 
                            try:
                                self.info('<'*80+'\n'+'triggering snapshot for alarm:'+tag_name)
                                if (self.Alarms[tag_name].severity!='DEBUG'): self.trigger_snapshot(tag_name)
                            except Exception, e:
                                self.warning('PyAlarm.trigger_snapshot crashed with exception:\n%s' % traceback.format_exc())
                    
                    if action_receivers:
                        self.info('checking %s actions ... %s'%(message,action_receivers))
                        [self.triggerAction(self.Alarms[tag_name],ac) for ac in action_receivers]
                else:
                    self.info('=============> ALARM SENDING DISABLED!!')

                self.Alarms[tag_name].sent += 1
                self.Alarms[tag_name].last_sent = time.time()
        except Exception,e:
            self.warning('PyAlarm.send_alarm crashed with exception:\n%s' % traceback.format_exc())
        self.info('-'*80)
        return

    def update_flag_file(self):
        ''' If there's Active Alarms writes a 1 to the file specified by FlagFile property, else writes 0 '''
        try:
            self.lock.acquire()
            AlarmsToNotify = self.get_active_alarms()
            self.info( 'update_flag_file: Writing %s to %s' % ('1\n' if AlarmsToNotify else '0\n' ,self.FlagFile))
            f=open(self.FlagFile,'w')
            f.writelines(['1\n' if AlarmsToNotify else '0\n'])
            f.close()
        except Exception,e:
            self.warning( 'Exception in PyAlarm.update_flag_file: %s' % traceback.format_exc())
        finally:
            self.lock.release()

    def update_log_file(self):
        if not hasattr(self,'LogFile') or not self.LogFile or self.LogFile.strip()=='/dev/null': return
        try:
            self.lock.acquire()
            f=open(self.LogFile,'a')
            report = []
            report.append('%s PyAlarm Device Server at %s\n\n' % (self.get_name(),time.ctime()))
            if self.get_active_alarms():
                report.append('Active Alarms are:\n')
                [report.append('\t%s:%s:%s\n'%(k,time.ctime(self.Alarms[k].active),self.Alarms[k].formula)) for k in self.get_active_alarms()]
            else: report.append( "There's No Active Alarms\n")
            if self.PastAlarms: 
                report.append( '\n\n' + 'Past Alarms were:' + '\n\t'.join([''] + ['%s:%s'%(','.join(k),time.ctime(d)) for d,k in self.PastAlarms.items()]) +'\n')
            f.writelines(report)
            f.close()
        except Exception,e:
            self.warning( 'Exception in PyAlarm.update_log_file: %s' % traceback.format_exc())
        finally:
            self.lock.release()

    def triggerAction(self, alarm, args):
        """  
        Executing a command on alarm/disable/reset/acknowledge: 
            ACTION(alarm:command,mach/alarm/beep/play_sequence,$DESCRIPTION)

        The syntax allow both attribute/command execution and the usage of multiple typed arguments: 
            ACTION(alarm:command,mach/dummy/motor/move,int(1),int(10))
            ACTION(reset:attribute,mach/dummy/motor/position,int(0))
        """
        if fun.isString(alarm): alarm = self.Alarms[alarm]
        action = args if fun.isSequence(args) else re.split('[,:;]',args)
        self.info('In PyAlarm.triggerAction(%s,%s)'%(alarm.tag,args))
        if action[0] in ('command','attribute'):
            try:
                dev = action[1].rsplit('/',1)[0]
                cmd = [action[1].rsplit('/',1)[1]]+action[2:]
                cmd = [c.replace('$ALARM',alarm.tag).replace('$DESCRIPTION',alarm.description).replace('$alarm',alarm.tag).replace('$description',alarm.description) for c in cmd]
                try: #This eval will allow to 
                    arg = eval(cmd[1]) if len(cmd)==2 else [eval(c) for c in cmd[1:]]
                except: 
                    arg = cmd[1] if len(cmd)==2 else cmd[1:]
                if action[0] == 'command':
                    self.info('\tlaunching: %s / %s (%s)' % (dev,cmd[0],cmd[1:]))
                    val = PyTango.DeviceProxy(dev).command_inout(cmd[0],arg)
                    self.info('\t'+str(val))
                else:
                    self.info('\tlaunching: %s / %s = %s' % (dev,cmd[0],cmd[1:]))
                    val = PyTango.DeviceProxy(dev).write_attribute(cmd[0],arg)
                    self.info('\t'+str(val))
            except:
                self.warning('Unable to execute action %s'%str(action))
                self.warning(traceback.format_exc())
        elif action[0]=='system' and action[1] in self.AllowedActions:
            try:
                os.system(action[1]+'&')
            except:
                self.warning('Unable to execute action %s'%str(action))
                self.warning(traceback.format_exc())
        else:
            self.warning('\tUnknown Action: %s'%action[0])

    ##@}
    #########################################################################################################

    ## @name Snap Contexts Methods
    #@{

    #SnapContext(359,Name,Author,Reason,Attributes[3],Snapshots[0])
    def trigger_snapshot(self,tag_name, user_comment=None):
        """
        First check for existing contexts with name=tag_name.
        If 1 exists and reason is Alarm, it is used. If reason is not, a new one is created.
        Then an snapshot is taken for the cotnext.
        """
        self.info( "In "+self.get_name()+"::trigger_snapshot(%s)"%tag_name)
        try:
            formula = self.Alarms[tag_name].formula
            self.info(formula)
            variables = self.Eval.parse_variables(formula)
            existingAttrsAllowed=[]
            for var in variables:
                if (self.snap.check_attribute_allowed(str(var[0]+'/'+var[1]))): 
                    existingAttrsAllowed.append(str(var[0]+'/'+var[1]))
    
            if (len(existingAttrsAllowed)==0):
                self.warning('Cannot take a snapshot - alarm attributes list empty!')
                return
    
            res=self.snap.db.search_context(tag_name)
            res = sorted(c for c in res if c['reason']=='ALARM')
            cids = [c['id_context'] for c in res]
            
            if not res: 
                if not self.CreateNewContexts: 
                    self.warning('Automatic Context Creation DISABLED!, Sorry, use CreateAlarmContext method')
                    return
                self.info('Creating ctx: name: '+tag_name+', descr: '+formula)
                self.info('atts:')
                for a in existingAttrsAllowed:
                    self.info(a)
                cid = self.CreateAlarmContext([tag_name]+existingAttrsAllowed)
                ctx = self.snap.get_context(cid)
                self.info('snap.descr: '+formula)
            else:
                if len(res)>1: self.warning('Multiple contexts declared for this Alarm!: %s'%str(cids))
                ctx=self.snap.get_context(cids[0])
    
            self.snap.db.update_context_attributes(self.snap.db.get_context_ids(tag_name)[0], existingAttrsAllowed)
            if user_comment:
                if 'DISABLED' in str(user_comment):
                    ctx.take_snapshot(comment=fandango.log.shortstr(user_comment,255))
                else: 
                    ctx.take_snapshot(comment=fandango.log.shortstr('ACKNOWLEDGED: %s'%user_comment,255))
            else: 
                ctx.take_snapshot(comment=fandango.log.shortstr('ALARM: %s'%self.Alarms[tag_name].description,255))
                
        except Exception,e:
            self.warning( 'Exception in trigger snapshot: %s' % traceback.format_exc())
        return
    ##@}

    def AddNewAlarm(self, argin):
        #@todo: This command has to be refactored and added as Expert command
        self.info( "In "+ self.get_name()+ "::AddNewAlarm()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            alarm = self.parse_alarm(argin)
            if not alarm:
                argout = 'INVALID ALARM FORMAT: %s'%alarm['tag']
            elif alarm['tag'] in self.Alarms:
                argout = 'ALARM TAG %s ALREADY EXISTS!'%alarm['tag']
            else:
                self.AlarmList.append(argin)
                self.init_device(update_properties=False)
                self.db.put_device_property(self.get_name(),{'AlarmList':self.AlarmList})
                argout = self.AlarmList[:]
        finally:
            self.lock.release()
        return argout

    def RemoveAlarm(self, argin):
        #@todo: This command has to be refactored and added as Expert command
        self.info("In "+self.get_name()+"::RemoveAlarm()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            if argin in self.Alarms and self.Alarms[argin].active: return 'ALARM SHOULD BE ACKNOWLEDGED FIRST!'
            match = [a for a in self.AlarmList if a.lower().startswith(argin.lower()+':')]
            if not match: return 'UNKNOWN ALARM TAG!'
            self.AlarmList.pop(match[0])
            self.init_device(update_properties=False)
            self.db.put_device_property(self.get_name(),{'AlarmList':self.AlarmList})
            argout = self.AlarmList[:]
        finally:
            self.lock.release()
        return argout 

    # #########################################################################################################

    ## @name POGO Generated Methods    

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)

        self.call__init__(fandango.log.Logger,name,format='%(levelname)-8s %(asctime)s %(name)s: %(message)s')
        self.setLogLevel('DEBUG')
        panic._proxies[name] = self

        #Persistent data:
        self.TStarted = time.time()
        self.Alarms = None #dictionary for Alarm Structs
        self.FailedAlarms = fandango.CaselessDict() #This list will keep a track of those alarms that couldn't be evaluated
        self.SMS_Sent = collections.deque() #Epochs when messages has been sent
        self.Proxies = defaultdict_fromkey(lambda key: PyTango.DeviceProxy(key)) #list of proxies
        self.PastAlarms = defaultdict_fromkey(lambda key: list()) #{date1:[tag1,tag2,tag3,...],date2:...}
        self.PastValues = {} #It will store the attribute values when the alarm was triggered.

        self.AcknowledgedAlarms = set() #This list will keep a track of acknowledged alarms
        self.DisabledAlarms = set() #This list will keep a track of disabled alarms

        self.LastAlarms = []
        self.SentEmails = collections.defaultdict(int)
        self.SentSMS = collections.defaultdict(int)
        
        self.Eval = None
        self.Uncatched = ''
        self.DynamicAttributes = []
        self._initialized = False #Enabled once dyn_attr has finished

        self.worker = None
        self.lock=threading.RLock();
        self.event=threading.Event();
        self.threadname=name
        self.updateThread = None
        self.last_attribute_check = 0
        self.db = PyTango.Database()
        
        #A class object will keep all declared alarms to search for children alarms and duplications
        if type(self).Panic is None: type(self).Panic = panic.AlarmAPI()
        self.debug('Out of __init__()')

        PyAlarm.init_device(self,allow=True)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def __del__(self):
        self.info( 'In PyAlarm.__del__() method ...')
        self.delete_device(True)

    def delete_device(self,allow=False):
        self.warning( "0[Device delete_device method] for device",self.get_name())
        if allow:
            self.set_state(PyTango.DevState.INIT)
            self.stop()
        if not allow: self.warning('init() is not allowed, please restart the server')

        # Do not do that or you may have seg faults!
        #print "1[Device delete_device method] for device",self.get_name()
        #for dp in self.Proxies.values(): del dp
        #print "2[Device delete_device method] for device",self.get_name()

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self,update_properties=True,allow=True):
        """
        This method will be called first for creating the device.
        It will be called afterwards to force a reloading of Alarms or Properties
        """
        self.info( "In "+self.get_name()+"::init_device()")
        if not allow: raise Exception('init() is not allowed, please restart the server')
        try:
            if update_properties or not self._initialized: 
                try:
                    #Reloading the alarm properties
                    self.lock.acquire()
                    if self.Alarms is None:
                        self.Alarms = panic.AlarmAPI(self.get_name()) #Everything that was active/inactive is erased here?
                    #This second part is not called for the first init(); only for the next ones
                    #It's just for checking if alarms has been added/removed from the API
                    else:
                        self.Alarms.load(self.get_name())
                        alarm_attrs = dict((a,v.get_attribute()) for a,v in self.Alarms.items())
                        for a in self.DynamicAttributes[:]:
                            if a not in alarm_attrs.values():
                                try:
                                    self.info('Removing %s attribute'%a)
                                    self.remove_attribute(a)
                                    self.DynamicAttributes.remove(a)
                                    if self.worker: self.worker.pop(a)
                                except:
                                    self.warning( traceback.format_exc())
                        for a,v in alarm_attrs.items():
                            if v not in self.DynamicAttributes[:]:
                                self.create_alarm_attribute(a)
                except Exception,e:
                    raise e
                finally: self.lock.release()
                self.get_device_properties(self.get_device_class())
                if self.PollingPeriod>999: self.PollingPeriod = self.PollingPeriod*1e-3 #Converting from ms to s
                if str(self.AlertOnRecovery).strip().lower() in ('false','no','none'): self.AlertOnRecovery=''
                if str(self.Reminder).strip().lower()=='false': self.Reminder=0
                if self.Eval is None:
                    self.Eval = (SingletonTangoEval if self.UseProcess and PROCESS else TangoEval)(timeout=500,trace=self.LogLevel.upper()=='DEBUG',cache=2*self.AlarmThreshold)
                    self.Eval.update_locals(dict(zip('DOMAIN FAMILY MEMBER'.split(),self.get_name().split('/'))))
                    self.Eval.set_timeout(self.EvalTimeout)
                if hasattr(self.Eval,'clear'): self.Eval.clear()
                if self.UseProcess and PROCESS and not self.worker:
                    #Do not reduce worker timeout or you may have problems if main thread idles (e.g. Tango database is down).
                    self.worker = WorkerProcess(self.Eval,start=True,timeout=self.PollingPeriod*max((self.AlarmThreshold,3)))
                    self.info('Configuring WorkerProcess ...')
                    self.worker.command('import threading')
                    self.worker.send('wait','threading.Event().wait(%d)'%self.StartupDelay)
                    #,timewait=0.05*self.PollingPeriod/len(self.Alarms))
                    self.worker.add('previous',target='dict([(k,str(v)) for k,v in executor.previous.items()])',args='',period=self.PollingPeriod/2.,expire=self.AlarmThreshold*self.PollingPeriod)
                    try: 
                        self.worker.command('import taurus')
                        self.worker.add('update_polling','[taurus.Attribute(a).changePollingPeriod(%d) for a in taurus.Factory().tango_attrs.keys()]'%max((3000,1000*self.PollingPeriod/2)),period=self.PollingPeriod)
                    except: print traceback.format_exc()
                    self.info('Configured WorkerProcess ...')
                elif self.worker:
                    self.worker.send('set_timeout','set_timeout',self.EvalTimeout)
                    # If it was not done in dyn_attr has to be redone here.
                    for a,v in self.Alarms.items():
                        self.worker.add(a,'eval',{'formula':v.formula,'_raise':True},period=self.PollingPeriod,expire=4*self.PollingPeriod) #<---- timeouts here!
                self.PhoneBook = self.Alarms.phonebook
                if '$NAME' in self.LogFile:
                    self.LogFile = self.LogFile.replace('$NAME',self.get_name().replace('/','-'))

            self.AddressList = dict(self.PhoneBook)
            #This check has been already done in AlarmAPI.get_phonebook(); it can be checked and removed from here
            for name,value in self.AddressList.items():
                for v in value.split(','):
                    if v in self.AddressList:
                        self.AddressList[name] = self.AddressList[name].replace(v,self.AddressList[v])

            #self.info("The contents of the phone book is: %s" % self.AddressList)
            self.info("Current Alarm server configuration is:\n\t"+"\n\t".join("%s: %s"%(k,getattr(self,k,None)) for k in 
                ('Reminder','AutoReset','AlarmThreshold','AlertOnRecovery','PollingPeriod','MaxAlarmsPerDay','MaxMessagesPerAlarm'))+'\n')
            for tag,alarm in self.Alarms.items():
                self.info('\n\t%s: %s\n\t\tFormula: %s\n\t\tSeverity: %s\n\t\tReceivers: %s'%(tag,alarm.description,alarm.formula,alarm.severity,alarm.receivers))

            #Create Alarm Attributes (not called in first init(), only afterwards
            if self._initialized: self.dyn_attr()

            #Get SnapConfig
            #if SNAP_ALLOWED and self.UseSnap:
            if SNAP_ALLOWED:
                try:
                    self.snap = snap.SnapAPI()
                except Exception,e: self.warning('SnapConfig failed: %s'%e)

            if not self._initialized: 
                self.set_state(PyTango.DevState.ON)
            if not self.updateThread or not self.updateThread.isAlive(): 
                self.start()
            self.info( 'Ready to accept request ...'+'<'*40)
            self.setLogLevel(self.LogLevel)
        except Exception,e:
            self.info( 'Exception in PyAlarm.init_device(): \n%s'%traceback.format_exc())
            self.set_state(PyTango.DevState.FAULT)
            raise e
        return

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug("In "+ self.get_name()+ "::always_excuted_hook()")
        try:
            actives = list(reversed([(v.active,k) for k,v in self.Alarms.items() if v.active]))
            if self.last_attribute_check and self.last_attribute_check<(time.time()-600.):
                self.set_state(PyTango.DevState.FAULT)
                self.set_status('Alarm Values not being updated!!!')
            elif self.worker and not (self.worker._process.is_alive() and self.worker._receiver.is_alive()):
                self.set_state(PyTango.DevState.FAULT)
                self.set_status('Alarm Values not being processed!!!') 
            else:
                self.set_state(PyTango.DevState.DISABLE if not self.Enabled else (PyTango.DevState.ALARM if actives else PyTango.DevState.ON))

                status = "There are %d active alarms\n" % len(actives)
                for date,tag_name in actives:
                    status+='%s:%s:\n\t%s\n\tSeverity:%s\n\tSent to:%s\n' % (time.ctime(date),tag_name,self.Alarms[tag_name].description,self.Alarms[tag_name].severity,self.Alarms[tag_name].receivers)
                if self.FailedAlarms:
                    status+='\n%d alarms couldnt be evaluated:\n%s'%(len(self.FailedAlarms),','.join(str(t) for t in self.FailedAlarms.items()))
                if self.Uncatched:
                    status+='\nUncatched exceptions:\n%s'%self.Uncatched
                self.set_status(status)
        except:
            self.warning( traceback.format_exc())


#==================================================================
#
#    PyAlarm read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        self.debug("In "+self.get_name()+"::read_attr_hardware()")


#------------------------------------------------------------------
#    Read LastAlarm attribute
#------------------------------------------------------------------
    def read_LastAlarm(self, attr):
        self.debug( "In "+self.get_name()+"::read_LastAlarm()")

        #    Add your own code here
        attr_LastAlarm_read = ""
        try:
            self.lock.acquire()
            attr_LastAlarm_read = self.LastAlarms.pop(0)
        finally:
            self.lock.release()
        attr.set_value(attr_LastAlarm_read)

#---- LastAlarm attribute State Machine -----------------
    def is_LastAlarm_allowed(self,req_type=None):
            #if self.get_state() in [PyTango.DevState.INIT]:
            if not self.LastAlarms:
                    #       End of Generated Code
                    #       Re-Start of Generated Code
                    self.info('LastAlarms list is emptied once it is read, is used only for archiving purposes.')
                    PyTango.Except.throw_exception('EmptyList','LastAlarms already read/archived','read_LastAlarm')
                    return False
            return True

#------------------------------------------------------------------
#    Read AlarmConfiguration attribute
#------------------------------------------------------------------
    def read_AlarmConfiguration(self, attr):
        self.debug("In "+self.get_name()+"::read_AlarmConfiguration()")

        #    Add your own code here
        attr_AlarmConfig_read = []
        attr_AlarmConfig_read = ['%s:%s'%(property,getattr(self,property)) for property in PyAlarmClass.device_property_list.keys() if property not in panic.ALARM_TABLES]
        attr.set_value(attr_AlarmConfig_read)

#------------------------------------------------------------------
#    Read ActiveAlarms attribute
#------------------------------------------------------------------
    def read_ActiveAlarms(self, attr):
        self.debug( "In "+self.get_name()+"::read_ActiveAlarms()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_ActiveAlarms_read = ['%s:%s:%s' % (tag_name,time.ctime(alarm.active),alarm.formula) 
                for tag_name,alarm in self.Alarms.items() if alarm.active][-512:]
            attr.set_value(attr_ActiveAlarms_read, len(attr_ActiveAlarms_read))
        finally: self.lock.release()

#------------------------------------------------------------------
#    Read AcknowledgedAlarms attribute
#------------------------------------------------------------------
    def read_AcknowledgedAlarms(self, attr):
        self.debug( "In "+self.get_name()+"::read_AcknowledgedAlarms()")

        #    Add your own code here
        attr_AcknowledgedAlarms_read = list(self.AcknowledgedAlarms)[-512:]
        attr.set_value(attr_AcknowledgedAlarms_read, len(attr_AcknowledgedAlarms_read))

#------------------------------------------------------------------
#    Read DisabledAlarms attribute
#------------------------------------------------------------------
    def read_DisabledAlarms(self, attr):
        self.debug( "In "+self.get_name()+"::read_DisabledAlarms()")

        #    Add your own code here
        attr_DisabledAlarms_read = list(self.DisabledAlarms)[-512:]
        attr.set_value(attr_DisabledAlarms_read, len(attr_DisabledAlarms_read))

#------------------------------------------------------------------
#    Read FailedAlarms attribute
#------------------------------------------------------------------
    def read_FailedAlarms(self, attr):
        self.debug( "In "+self.get_name()+"::read_FailedAlarms()")

        #    Add your own code here
        attr_FailedAlarms_read = self.FailedAlarms.keys()[-512:]
        attr.set_value(attr_FailedAlarms_read, len(attr_FailedAlarms_read))


#------------------------------------------------------------------
#    Read PastAlarms attribute
#------------------------------------------------------------------
    def read_PastAlarms(self, attr):
        self.debug( "In "+self.get_name()+"::read_PastAlarms()")

        #    Add your own code here
        attr_PastAlarms_read = []
        try:
            self.lock.acquire()
            dates = self.PastAlarms.keys()
            dates.sort(reverse=True)
            for date in dates:
                for tag_name in self.PastAlarms[date]:
                    attr_PastAlarms_read.append('%s:%s:%s' % (tag_name,time.ctime(date),self.Alarms[tag_name].formula))
                    if len(attr_PastAlarms_read) == 512: break
            #if len(attr_PastAlarms_read)>512: attr_PastAlarms_read = attr_PastAlarms_read[-512:]
        finally:
            self.lock.release()
        attr.set_value(attr_PastAlarms_read, len(attr_PastAlarms_read))


#------------------------------------------------------------------
#    Read AlarmList attribute
#------------------------------------------------------------------
    def read_AlarmList(self, attr):
        self.debug( "In "+self.get_name()+"::read_AlarmList()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_AlarmList_read = ['%s:%s:%s'%(alarm.tag,alarm.description,alarm.formula) for alarm in self.Alarms.values()]
            attr.set_value(attr_AlarmList_read, len(self.Alarms))
        finally:
            self.lock.release()

#------------------------------------------------------------------
#    Read AlarmReceivers attribute
#------------------------------------------------------------------
    def read_AlarmReceivers(self, attr):
        self.debug( "In "+self.get_name()+"::read_AlarmReceivers()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_AlarmReceivers_read = ['%s:%s'%(k,v.receivers) for k,v in self.Alarms.items()]
        finally:
            self.lock.release()
        attr.set_value(attr_AlarmReceivers_read, len(attr_AlarmReceivers_read))


#------------------------------------------------------------------
#    Read PhoneBook attribute
#------------------------------------------------------------------
    def read_PhoneBook(self, attr):
        self.debug( "In "+self.get_name()+"::read_PhoneBook()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_PhoneBook_read = ['%s:%s'%(k,v) for k,v in self.AddressList.items() if v]
        finally:
            self.lock.release()
        attr.set_value(attr_PhoneBook_read, len(attr_PhoneBook_read))        


#------------------------------------------------------------------
#    Read SentEmails attribute
#------------------------------------------------------------------
    def read_SentEmails(self, attr):
        self.debug( "In "+self.get_name()+"::read_SentEmails()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_SentEmails_read = []
            for key,value in self.SentEmails.items():
                attr_SentEmails_read.append(key)
                attr_SentEmails_read.append(str(value))
            self.info( 'SentEmails are: %s'%attr_SentEmails_read)
        finally:
            self.lock.release()
        attr.set_value(attr_SentEmails_read, 2, len(attr_SentEmails_read)/2)


#------------------------------------------------------------------
#    Read SentSMS attribute
#------------------------------------------------------------------
    def read_SentSMS(self, attr):
        self.debug( "In "+self.get_name()+"::read_SentSMS()")

        #    Add your own code here
        try:
            self.lock.acquire()
            attr_SentSMS_read = []
            for key,value in self.SentSMS.items():
                attr_SentSMS_read.append(key)
                attr_SentSMS_read.append(str(value))
            self.debug( 'SentSMS are: %s'%attr_SentSMS_read)
        finally:
            self.lock.release()
        attr.set_value(attr_SentSMS_read, 2, len(attr_SentSMS_read)/2)


#==================================================================
#
#    PyAlarm command methods
#
#==================================================================

#------------------------------------------------------------------
#    ResetAlarm command:
#
#    Description: Reset alarm, it will be removed from active alarms
#
#    argin:  DevVarStringArray    This is used to inform which alarm should be reset and message. If it doesn't exst an error occurs
#    argout: DevVarStringArray    If succeed, returns the list of ActiveAlarms
#------------------------------------------------------------------
    def ResetAlarm(self, argin):
        self.info( "In "+self.get_name()+"::ResetAlarm()")
        #    Add your own code here
        if len(argin)==1: raise Exception('UserMessageRequiredAs2ndArgument')#tag,userMessage = argin[0],''
        else: tag,userMessage = argin[:2]

        argout = self.get_active_alarms() if self.free_alarm(tag, userMessage, message='RESET') else [] 
        return argout

#------------------------------------------------------------------
#    Acknowledge command:
#
#    Description: Acknowledge alarm no more reminders will be sent
#
#    argin:  DevString    This is used to inform which alarm should be acknowledged. , no more reminders will be sent.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Acknowledge(self, argin):
        self.info( "In "+self.get_name()+"::Acknowledge()")
        #    Add your own code here
        if len(argin)==1: tag,userMessage = argin[0],''
        else: tag,userMessage = argin[:2]
        if str(argin[0]) in self.Alarms:
            self.Alarms[str(argin[0])].acknowledged = time.time()
            self.AcknowledgedAlarms.add(str(argin[0]))

        argout = self.get_active_alarms() if self.free_alarm(tag, userMessage, message='ACKNOWLEDGED') else []
        return argout

#------------------------------------------------------------------
#    Renounce command:
#
#    Description: Renounce (opposite to acknowledge) all emails will be send again
#
#    argin:  DevString    This is used to inform which alarm should be renounced.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Renounce(self, argin):
        self.info( "In "+self.get_name()+"::Renounce()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.Alarms:
            self.Alarms[argin].acknowledged = 0
            self.AcknowledgedAlarms.remove(argin)
            return 'DONE'
        else: return '%s_NotFound'%argin

#------------------------------------------------------------------
#    Enable command:
#
#    Description: Enable alarm that was put to disable state
#
#    argin:  DevString    This is used to inform which alarm should be enabled.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Enable(self, argin):
        self.info( "In "+self.get_name()+"::Enable()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.Alarms:
            #self.Alarms[argin].active = True
            self.DisabledAlarms.remove(argin)
            return 'DONE'
        else: return '%s_NotFound'%argin

#------------------------------------------------------------------
#    Disable command:
#
#    Description: Disable enabled alarm.
#
#    argin:  DevString    This is used to inform which alarm should be disabled.
#    argout: DevString    If succeed, returns DONE
#------------------------------------------------------------------
    def Disable(self, argin):
        self.info( "In "+self.get_name()+"::Disable()")
        #    Add your own code here
        if len(argin)==1: tag,userMessage = argin[0],''
        else: tag,userMessage = argin[:2]
        if str(argin[0]) in self.Alarms:
            self.free_alarm(tag, userMessage, message='DISABLED')
            self.Alarms[str(argin[0])].active = 0
            self.DisabledAlarms.add(str(argin[0]))

            return 'DONE'
        else: return '%s_NotFound'%argin

#------------------------------------------------------------------
#    CheckDisabled command:
#
#    Description: Check if the alarm is on DisabledAlarms list.
#
#    argin:  DevString    This is used to inform which alarm should be checked.
#    argout: DevBoolean   True if alarm is disabled else False    
#------------------------------------------------------------------
    def CheckDisabled(self, argin):
        self.debug( "In "+self.get_name()+"::CheckDisabled()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.DisabledAlarms: return True
        else: return False

#------------------------------------------------------------------
#    CheckAcknowledged command:
#
#    Description: Check if the alarm is on AcknowledgedAlarms list.
#
#    argin:  DevString    This is used to inform which alarm should be checked.
#    argout: DevBoolean   True if alarm is acknowledged else False    
#------------------------------------------------------------------
    def CheckAcknowledged(self, argin):
        self.debug( "In "+self.get_name()+"::CheckAcknowledged()")
        #    Add your own code here
        argin = str(argin)
        if argin in self.AcknowledgedAlarms: return True
        else: return False

#------------------------------------------------------------------
#    ResetAll command:
#
#    Description: Acknowledge alarm that was put into the file with alarms, it will be removed from active alarms
#
#    argin:  DevString    This command requires a user message
#    argout: DevString    If succed, returns the list of ActiveAlarms reseted
#------------------------------------------------------------------
    def ResetAll(self, argin):
        self.info( "In "+self.get_name()+"::ResetAll()")
        #    Add your own code here
        argout = self.get_active_alarms()
        [self.ResetAlarm([key,argin[0]]) for key in argout]
        return 'RESET:'+','.join(argout or ['DONE'])
    
#------------------------------------------------------------------
#    GetRelease command:
#
#    Description: 
#
#    argin:  DevVoid 
#    argout: DevString
#------------------------------------------------------------------
    def GetRelease(self, argin=None):
        self.info( "In "+self.get_name()+"::GetRelease()")
        #    Add your own code here
        return str(__RELEASE__)

#------------------------------------------------------------------
#    AddReceiver command:
#
#    Description: Returns the actual value of AlarmReceivers
#
#    argin:  DevVarStringArray    Attribute,ReceiverAddress
#    argout: DevVarStringArray    Adds a new Receiver to AlarmReceivers property
#------------------------------------------------------------------
    def AddReceiver(self, argin):
        self.info( "In "+ self.get_name()+ "::AddReceiver()")
        #    Add your own code here
        argout = ['FAILED']
        try:
            self.lock.acquire()
            self.Alarms[argin[0]].add_receiver(argin[1])
            argout = ['%s:%s'%(tag,','.join(alarm.receivers)) for tag,alarm in self.Alarms.items()]
        finally:
            self.lock.release()
        return argout

#------------------------------------------------------------------
#    GenerateReport command:
#
#    Description: Generates report message
#
#    argin:  DevVarStringArray    tag,message,receivers,...,description
#    argout: DevVarStringArray
#------------------------------------------------------------------

    def GenerateReport(self,tag_name,mail_receivers='',message='DETAILS',values=None, user_comment=None, html=False):
        """
        When called from Tango a single argument is received; which is a list containing all arguments
        :param message: Can be one of self.MESSAGE_TYPES or a different text
        """
        self.debug( '>'*80)
        #Sending emails
        #-----------------------------------------------------------------------------------------------
        if not mail_receivers and hasattr(tag_name,'__iter__'):
            #This line is executed only when calling from an external Tango client
            tag_name,mail_receivers,message = tag_name[0],tag_name[1:-1],tag_name[-1]
        if fun.isString(mail_receivers):
            mail_receivers = mail_receivers.split(',')

        self.info( 'In GenerateReport(%s,%s,%s)'%(tag_name,mail_receivers,message))
        maillist = []
        alnum = '[a-zA-Z0-9-_.]+'
        email = '(' + alnum + '@' + '(?:' + alnum + r"[\.]" + ')+' + alnum + ')'
        alarm = (self.Alarms.get(tag_name) or [None])[0]
        result = 'FAILED'
        # ( alnum at (non-group-match?: alnum dot)+ alnum ) #: It returns a list with all mail addresses

        for m in mail_receivers:
            addresses = re.findall(email,m)
            self.info( 'in %s, addresses=%s'%(m,addresses))
            [maillist.append(a.lower()) for a in addresses if a.lower() not in maillist]

        #if (maillist or (not maillist and html)):
        report = 'TAG: %s'%tag_name
        actives = self.get_active_alarms()
        subject = '%s %s'%(tag_name,message)
        values = values or self.PastValues.get(tag_name,None)

        if message in ('DETAILS',tag_name):
            first_row = ''
            if self.Alarms[tag_name].active:
                if self.Alarms[tag_name].recovered:
                    first_row += '\n\t' + 'Alarm conditions recovered at %s'%(time.ctime(self.Alarms[tag_name].recovered))
                first_row += '\n\t' + 'Alarm ACTIVE since %s'%(time.ctime(self.Alarms[tag_name].active or self.PastAlarms.get(tag_name,0)))
            else:
                first_row = '\n\t' + 'The alarm is not active.'
        elif message in ('ALARM','REMINDER'):
            first_row = '\n\t' + 'Alarm active since %s'%(time.ctime(self.Alarms[tag_name].active or self.PastAlarms.get(tag_name,0)))
        elif message in ('RECOVERED','AUTORESET'):
            first_row = '\n\t' + '%s at %s' %(message,time.ctime())
        elif message in ('ACKNOWLEDGED','RESET','DETAILS','DISABLED'):
            first_row = '\n\t' + '%s at %s' %(message,time.ctime())
            first_row += '\n\tDetails -> %s'%user_comment
        elif message not in self.MESSAGE_TYPES:
            first_row = '\n\t%s'%message

        report += first_row
        report += '\n\tAlarmDevice: %s'%self.get_name()
        report += '\n\tDescription: %s'%self.Alarms[tag_name].parse_description()
        report += '\n\tSeverity: %s'%self.Alarms[tag_name].parse_severity()
        report += '\n\tFormula: %s'%(self.Alarms[tag_name].formula)
        if values:
            #report += '\n\n' + 'Values were: \n\t' + ('\n\t'.join('%s:\t%s'%(k,v) for k,v in sorted(values.items())) if hasattr(values,'items') else str(values))
            report += '\n\n' + 'Values are: \n\t'
            if hasattr(values,'items'):
                try: report += ('\n\t'.join('%s:\t%s'%(k if not self.Panic.findChild(k) else '<a href="%s.html">%s</a>'%(k.split('/')[-1],k),v) for k,v in sorted(values.items())))
                except: report += str(values).strip() or traceback.format_exc()
            else: report+= str(values).strip()
        if maillist and len(maillist)>1:
            report += '\n\n' + 'Alarm receivers are: ' + '\n\t'.join([''] + maillist)
        if len(actives) > 1:
            try: report+= '\n\n' + 'Other Active Alarms are:' + '\n\t'.join([''] + sorted(['%s:%s:%s'%(k,time.ctime(v.active),self.Alarms[k].formula) for k,v in self.Alarms.items() if v.active]))
            except: pass
        if self.PastAlarms:
            self.info( self.PastAlarms)
            report+= '\n\n' + 'Past Alarms were:' + '\n\t'.join([''] + ['%s:%s'%(','.join(k),time.ctime(d)) for d,k in self.PastAlarms.items()])
        if html:
            result = [report, subject]
        else:
            result = [report, subject, ','.join(maillist)]
        #else:
            #self.warning( 'The mailing list for %s is empty!'%tag_name)
        self.info( 'Out of GenerateReport(%s,%s,%s)'%(tag_name,mail_receivers,message))
        self.info( '>'*80)
        return result
        
#------------------------------------------------------------------
#    CreateAlarmContext command:
#
#    Description: Creates an Snap context for this Alarm
#
#    argin:  DevVarStringArray    tag,attributes
#    argout: DevLong              new context id
#------------------------------------------------------------------
    def CreateAlarmContext(self, argin):
        tag_name,existingAttrsAllowed = argin[0],argin[1:]
        self.info('In CreateAlarmContext(%s,%s)'%(tag_name,existingAttrsAllowed))
        res=self.snap.db.search_context(tag_name)
        res = sorted(c for c in res if c['reason']=='ALARM')
        cids = [c['id_context'] for c in res]
        if cids:
            self.warning('Cannot create a context - already exist!')
            return cids[0]
        if not existingAttrsAllowed:
            vars = self.Eval.parse_variables(self.Alarms[tag_name].formula)
            existingAttrsAllowed = [str(var[0]+'/'+var[1]) for var in vars if (self.snap.check_attribute_allowed(str(var[0]+'/'+var[1])))]
        if not existingAttrsAllowed:
            self.warning('Cannot create a context - alarm attributes list empty!')
            return -1        
        ctx=self.snap.create_context('AlarmAPP',tag_name,'ALARM',self.Alarms[tag_name].formula,existingAttrsAllowed)
        return ctx.ID

#------------------------------------------------------------------
#    SendMail command:
#
#    Description: Sends a mail message
#
#    argin:  DevVarStringArray    message,subject,receivers
#    argout: DevBoolean
#------------------------------------------------------------------

    def SendMail(self, argin):
        """
        Arguments: message, subject, receivers
        """
        def format4sendmail(report):
            MAX_MAIL_LENGTH = 512
            out = report.replace('\n','\\n')
            #if len(out)>MAX_MAIL_LENGTH: out = out[:(MAX_MAIL_LENGTH-5)]+'\\n...'
            return out
        try:
            #command = 'echo -e "'+format4sendmail(report)+'" | mail -s "%s" -r %s '%(subject,self.FromAddress) +','.join(maillist)
            command = 'echo -e "'+format4sendmail(argin[0])+'" '
            command += '| mail -s "%s" ' % argin[1]
            command += '-S from=%s ' % self.FromAddress #'-r %s ' % (self.FromAddress)
            command += (argin[2] if fun.isString(argin[2]) else ','.join(argin[2]))
            self.info( 'Launching mail command: '+command)
            os.system(command)
            for m in argin[2]:
                self.SentEmails[m.lower()]+=1
            return 'DONE'
        except Exception,e:
            self.info( 'Exception in PyAlarm.SendMail(): \n%s'%traceback.format_exc())
        return 'FAILED'

#------------------------------------------------------------------
#    SaveHtml command:
#
#    Description: Saves a html report
#
#    argin:  DevVarStringArray    message,subject
#    argout: DevBoolean
#------------------------------------------------------------------

    def SaveHtml(self, argin):
        def format4html(report):
            out='<pre>'+report+'</pre>'
            return out
        try:
            report=argin[1]+'\n'+argin[0]
            filename=argin[1].split(' ', 2)[1]+'.html'
            f=open(self.HtmlFolder+'/'+filename, 'w')
            report = format4html(report) 
            f.write(report)
            f.close()
            return report
        except Exception,e:
            self.warning( 'Exception in PyAlarm.SaveHtml(): \n%s'%traceback.format_exc())
        return 'FAILED'

#------------------------------------------------------------------
#    SendSMS command:
#
#    Description: Sends an SMS message
#
#    argin:  DevVarStringArray    tag/message,receivers,...,
#    argout: DevBoolean
#------------------------------------------------------------------

    def SendSMS(self,tag,receivers=[],message='TEST',values=None):
        """
        Sending sms, completely dependent of your personal SMS configuration.
        :param tag_name:    Alarm or Test message to be sent
        :param receivers:   SMS numbers to receive the alarm
        """
        if not receivers and hasattr(tag,'__iter__'):
            tag,receivers = tag[0],tag[1:]
        alarm = self.Alarms.get(tag,None)

        self.info( 'In SendSMS(%s,%s,%s,%s)'%(tag,receivers,message,values))
        if not SMS_ALLOWED or not 'smslib' in globals():
            self.warning( 'SMS Messaging is not allowed or smslib not available!!!')
            return
        report = ''
        username,password=self.SMSConfig.split(':',1)
        source = self.FromAddress 
        MAX_SMS_LENGTH=160
        now = time.time()
        try:
            self.lock.acquire()
            while self.SMS_Sent and self.SMS_Sent[0]<now-(24*60*60): self.SMS_Sent.popleft()
            sends = len(self.SMS_Sent)
        finally:
            self.lock.release()
        if sends>=self.MAX_SMS_DAY:
            self.warning( 'The limit of Daily SMS messages (%d) has been exceeded!' % self.MAX_SMS_DAY)
            return
        elif receivers:
            sms = '((SMS:)?([\+]?[0-9]{9,13}))'
            smslist = []
            for s in receivers:
                numbers = re.findall(sms,s)
                [smslist.append(t[-1]) for t in numbers if t and len(t)>1]
                smslist = list(set(smslist))
            if smslist:
                try:
                    self.lock.acquire()
                    self.info( 'SMS Sending: the phone numbers to be reported for %s are: %s' % (tag,','.join(smslist)) )
                    if message in ('ALARM',) and tag in self.Alarms:
                      formula,text = self.Alarms[tag].formula, ';%s'%self.Alarms[tag].parse_description()
                    else:
                        formula,text = '',';%s'%message
                    report = 'Alarm '+tag+': '+text
                    if values: report += ';Values=' + str(values).replace('{','').replace('}','')[:MAX_SMS_LENGTH-len(report)-1]
                    #for sms in smslist: #For unknown reasons it fails when passing a list of numbers
                    self.info( 'SMS Sending: message is: %s' % (report))
                except:
                    self.warning( 'Exception generating SMS report: %s' % traceback.format_exc())
                finally:
                    self.lock.release()

                if 'sms' not in self.AlertOnRecovery.lower() and message.strip() not in ('ALARM','TEST'):
                    self.warning('SMS sending not allowed for %s message type.'%message)
                else:
                    #To avoid device hungs all SMS messages are sent in a background thread
                    if not hasattr(self,'sms_threads'): self.sms_threads = 0
                    self.sms_threads += 1
                    self.info( 'Sending SMS in a different Thread ... '+'SMS-Send%d'%self.sms_threads)
                    thr = smslib.SMSThread(message=report, dest=smslist, username=username, password=password, source=str(source.split('@')[0]))
                    thr.setDaemon(True)
                    thr.start()
                    try:
                        self.lock.acquire()
                        self.SMS_Sent.append(now)
                        self.info( '%d SMS messages sent in the last 24 hours.' % len(self.SMS_Sent))
                    finally:
                        self.lock.release()
                    for s in smslist:
                        self.SentSMS[s.lower()]+=1
                return 'DONE'
        return 'FAILED'


#==================================================================
#
#    PyAlarmClass class definition
#
#==================================================================
class PyAlarmClass(PyTango.DeviceClass):
#class PyAlarmClass(PyTango.PyDeviceClass):

    #    Class Properties
    class_property_list = {
        'PhoneBook':
            [PyTango.DevVarStringArray,
            "List of alarms declared like:. User:user@accelerator.es;SMS:+34666555666",
            [] ],
        'SMSConfig':
            [PyTango.DevString,
            "Arguments for sendSMS command",
            [ ":" ] ],
        'FromAddress':
            [PyTango.DevString,
            "Address that will appear as Sender in mail and SMS",
            [ "oncall" ] ],
        'AllowedActions':
            [PyTango.DevVarStringArray,
            "List of OS commands that alarms are able to execute.",
            [] ],
        'StartupDelay':
            [PyTango.DevLong,
            "Number of seconds that PyAlarm will wait before starting to evaluate alarms.",
            [ 60 ] ],
        }

    #    Device Properties
    device_property_list = {
        # Alarm Properties: This properties will be managed by API; DON'T ACCESS THEM WITH self.
        'AlarmList':
            [PyTango.DevVarStringArray,
            "List of alarms to be monitorized. The format is:\n<br>domain/family/member #It simply checks that dev is alive\n<br>domain/family/member/attribute > VALUE\n<br>domain/family/member/State == UNKNOWN\n<br>domain/family/*/Temperature > VALUE\n<br>\n<br>When using wildcards all slash / must be included",
            [] ],
        'AlarmReceivers':
            [PyTango.DevVarStringArray,
            "Users that will be notified for each alarm. The format is:\n<br>[TYPE]:[ADDRESS]:[attributes];...\n<br>\n<br>[TYPE]: MAIL / SMS\n<br>[ADDRESS] : operator@accelerator.es / +34666555444\n<br>[attributes]: domain/family/member/attribute;domain/family/*",
            [] ],
        'AlarmDescriptions':
            [PyTango.DevVarStringArray,
            "Description to be included in emails for each alarm. The format is:\n<br>TAG:AlarmDescription...",
            [] ],
        'AlarmConfigurations':
            [PyTango.DevVarStringArray,
            "Configuration customization appliable to each alarm. The format is:\n<br>TAG:PAR1=Value1;PAR2=Value2;...",
            [] ],
        'AlarmSeverities':
            [PyTango.DevVarStringArray,
            "ALARM:DEBUG/INFO/WARNING/ERROR #DEBUG alarms will not trigger messages",
            [] ],

        # Configuration Properties: This properties can be accessed as self.Property
        'LogFile':
            [PyTango.DevString,
            "File where alarms are logged, like /tmp/alarm_$NAME.log",
            [ "" ] ],
        'LogLevel':
            [PyTango.DevString,
            "stdout log filter",
            [ "INFO" ] ],
        'HtmlFolder':
            [PyTango.DevString,
            "File where alarm reports are saved",
            [ "htmlreports" ] ],
        'AlarmThreshold':
            [PyTango.DevLong,
            "Min number of consecutive Events/Pollings that must trigger an Alarm.",
            [ 3 ] ],
        'Enabled':
            [PyTango.DevBoolean,
            "If False forces the device to Disabled state and avoids messaging.",
            [ True ] ],
        'AlertOnRecovery':
            [PyTango.DevString,
            "It can contain 'email' and/or 'sms' keywords to specify if an automatic message must be sent in case of alarm returning to safe level.",
            [ "false" ] ],
        'FlagFile':
            [PyTango.DevString,
            "File where a 1 or 0 value will be written depending if theres active alarms or not.\n<br>This file can be used by other notification systems.",
            [ "/tmp/alarm_ds.nagios" ] ],
        'PollingPeriod':
            [PyTango.DevLong,
            "Periode in seconds in which all attributes not event-driven will be polled.",
            [ 15 ] ],
        'MaxAlarmsPerDay':
            [PyTango.DevLong,
            "Max Number of Alarms to be sent each day to the same receiver.",
            [ 3 ] ],
        'MaxMessagesPerAlarm':
            [PyTango.DevLong,
            "Max Number of messages to be sent each time that an Alarm is activated/recovered/reset.",
            [ 20 ] ],
        'FromAddress':
            [PyTango.DevString,
            "Address that will appear as Sender in mail and SMS",
            [ "oncall" ] ],
        'SMSConfig':
            [PyTango.DevString,
            "Arguments for sendSMS command",
            [ ":" ] ],
        'UseSnap':
            [PyTango.DevBoolean,
            "If false no snapshots will be trigered (unless specifically added to receivers)",
            [ True ] ],
        'CreateNewContexts':
            [PyTango.DevBoolean,
            "It enables PyAlarm to create new contexts for alarms if no matching context exists in the database.",
            [ False ] ],
        'Reminder':
            [PyTango.DevLong,
            "If a number of seconds is set, a reminder mail will be sent while the alarm is still active, if 0 no Reminder will be sent.",
            [ 0 ] ],
        'AutoReset':
            [PyTango.DevLong,
            "If a number of seconds is set, the alarm will reset if the conditions are no longer active after the given interval.",
            [ 3600 ] ],
        'StartupDelay':
            [PyTango.DevLong,
            "Number of seconds that PyAlarm will wait before starting to evaluate alarms.",
            [ 0 ] ],
        'EvalTimeout':
            [PyTango.DevLong,
            "Timeout for read_attribute calls, in milliseconds .",
            [ 500 ] ],
        'UseProcess':
            [PyTango.DevBoolean,
            "To create new OS processes instead of threads.",
            [ False ] ],
        'RethrowState':
            [PyTango.DevBoolean,
            "Whether exceptions in State reading will be rethrown.",
            [ True ] ],
        'RethrowAttribute':
            [PyTango.DevBoolean,
            "Whether exceptions in Attribute reading will be rethrown.",
            [ False ] ],
        }

    #    Command definitions
    cmd_list = {
        'AddReceiver':
            [[PyTango.DevVarStringArray, "Attribute,ReceiverAddress"],
            [PyTango.DevVarStringArray, "AlarmReceivers values"],
            {
                #'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'ResetAlarm':
            [[PyTango.DevVarStringArray, "This is used to inform which alarm should be reset. If it doesn't exst an error occurs, comment"],
            [PyTango.DevVarStringArray, "If succeed, returns the list of ActiveAlarms"]],
        'Acknowledge':
            [[PyTango.DevVarStringArray, "This is used to inform which alarm should be acknowledged, no more reminders will be sent, comment"],
            [PyTango.DevVarStringArray, "If succeed, returns the list of ActiveAlarms"]],
        'Renounce':
            [[PyTango.DevString, "This is used to inform which alarm should be renounced, all reminders will be send again."],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'Enable':
            [[PyTango.DevString, "(TAG,) This is used to inform which alarm should be enabled, alarm won't skip the updateAlarms loop"],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'Disable':
            [[PyTango.DevVarStringArray, "(TAG,comment) This is used to inform which alarm should be disabled, alarm will skip the updateAlarms loop, comment"],
            [PyTango.DevString, "If succeed, returns DONE"]],
        'ResetAll':
            [[PyTango.DevVarStringArray, "User message"],
            [PyTango.DevString, ""]],
        'GetRelease':
            [[PyTango.DevVoid, ""],
            [PyTango.DevString, ""]],
        'GenerateReport':
            [[PyTango.DevVarStringArray, "tag,message,receivers,...,description"],
            [PyTango.DevVarStringArray,"result, subject, receivers"]],
        'CreateAlarmContext':
            [[PyTango.DevVarStringArray, "tag,attributes,..."],
            [PyTango.DevLong,"new context ID"]],
        'SendMail':
            [[PyTango.DevVarStringArray, "message,subject,receivers"],
            [PyTango.DevString,""]],
        'SaveHtml':
            [[PyTango.DevVarStringArray, "message,subject"],
            [PyTango.DevString,""]],
        'SendSMS':
            [[PyTango.DevVarStringArray, "tag/message,receivers,..."],
            [PyTango.DevString,""]],
        'CheckAcknowledged':
            [[PyTango.DevString, "alarm tag"],
            [PyTango.DevBoolean,"true if alarm is on the list else false"]],
        'CheckDisabled':
            [[PyTango.DevString, "alarm tag"],
            [PyTango.DevBoolean,"true if alarm is on the list else false"]],
        }

    #    Attribute definitions
    attr_list = {
        'LastAlarm':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Returns Alarm:AlarmDate for last alarms until each is read once, then it's cleared (used for archiving)",
            } ],
        'AlarmConfiguration':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'Display level':PyTango.DispLevel.EXPERT,
                'description':"Returns Property:Value list",
            } ],
        'ActiveAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Retrieves a list of Active Alarms showing AlarmDate:AlarmDescription",
            } ],
        'PastAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns AlarmDate:ACKDate:AlarmDescription for all OLD alarms already acknowledged",
            } ],
        'AlarmList':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns the content of the AlarmList property",
            } ],
        'AlarmReceivers':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512],
            {
                'description':"Returns the content of the AlarmReceivers property",
            } ],
        'PhoneBook':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'SentEmails':
            [[PyTango.DevString,
            PyTango.IMAGE,
            PyTango.READ, 512,512]],
        'SentSMS':
            [[PyTango.DevString,
            PyTango.IMAGE,
            PyTango.READ, 512,512]],
        'AcknowledgedAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'DisabledAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        'FailedAlarms':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 512]],
        }

    def dyn_attr(self,dev_list):
        print ( '>'*40)
        print ("In PyAlarmClass.dyn_attr(%s)"%dev_list)
        for dev in dev_list:
            dev.dyn_attr()

#------------------------------------------------------------------
#    PyAlarmClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print ( "In PyAlarmClass  constructor")

#==================================================================
#
#    PyAlarm class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(PyAlarmClass,PyAlarm,'PyAlarm')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
